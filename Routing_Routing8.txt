from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER
from ryu.controller.handler import set_ev_cls
from ryu.ofproto import ofproto_v1_3
from ryu.lib.packet import packet, ethernet, arp, ipv4, icmp, udp, dhcp, ether_types
from ryu.lib import addrconv
import struct
from ipaddress import ip_address, ip_network
import time
import logging
import networkx as nx
import random

class CombinedApp(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

    # DHCP Constants
    DHCP_DISCOVER = 1
    DHCP_OFFER = 2
    DHCP_REQUEST = 3
    DHCP_ACK = 5
    DHCP_NAK = 6
    DHCP_RELEASE = 7

    # DHCP Option Tags
    DHCP_MESSAGE_TYPE = 53
    DHCP_SERVER_ID = 54
    DHCP_LEASE_TIME = 51
    DHCP_SUBNET_MASK = 1
    DHCP_ROUTER = 3
    DHCP_DNS_SERVER = 6
    DHCP_DOMAIN_NAME = 15
    DHCP_REQUESTED_IP = 50
    DHCP_END = 255

    def __init__(self, *args, **kwargs):
        super(CombinedApp, self).__init__(*args, **kwargs)

        # Multipath attributes
        self.mac_to_port = {}
        self.net = nx.DiGraph()
        self.switches = {}
        self.paths = {}
        self.switch_links = {}  # To track switch-to-switch connections

        # Routing/DHCP attributes
        shared_subnet = {
            'network': '192.168.0.64/22',
            'pool_range': ['192.168.0.70', '192.168.3.254'],
            'server_ip': '192.168.196.144',
            'subnet_mask': '255.255.252.0',
            'router': '192.168.0.65',
            'dns_server': '8.8.8.8',
            'domain_name': 'example.com',
            'lease_time': 86400
        }

        start_ip = ip_address(shared_subnet['pool_range'][0])
        end_ip = ip_address(shared_subnet['pool_range'][1])
        shared_pool = [str(ip_address(ip)) for ip in range(int(start_ip), int(end_ip) + 1)]
        shared_subnet['pool'] = shared_pool

        self.subnets = {
            's2': {
                'network': '192.168.4.0/25',
                'pool_range': ['192.168.4.4', '192.168.4.126'],
                'server_ip': '192.168.196.144',
                'subnet_mask': '255.255.255.128',
                'router': '192.168.4.1',
                'dns_server': '8.8.8.8',
                'domain_name': 'example.com',
                'lease_time': 86400,
                'pool': [str(ip_address(ip)) for ip in range(int(ip_address('192.168.4.4')),
                                                              int(ip_address('192.168.4.126')) + 1)]
            },
            's3': {
                'network': '192.168.0.0/26',
                'pool_range': ['192.168.0.4', '192.168.0.62'],
                'server_ip': '192.168.196.144',
                'subnet_mask': '255.255.255.192',
                'router': '192.168.0.1',
                'dns_server': '8.8.8.8',
                'domain_name': 'example.com',
                'lease_time': 86400,
                'pool': [str(ip_address(ip)) for ip in range(int(ip_address('192.168.0.4')),
                                                              int(ip_address('192.168.0.62')) + 1)]
            },
            's4': shared_subnet,
            's5': shared_subnet,
            's6': shared_subnet,
            's7': shared_subnet
        }

        self.leases = {}  # MAC -> {ip, subnet, lease_start, lease_end}
        self.server_mac = 'aa:bb:cc:dd:ee:ff'
        self.router_ips = {subnet: info['router'] for subnet, info in self.subnets.items()}
        self.router_mac = self.server_mac
        self.pending_packets = {}  # dst_ip -> list of (datapath, in_port, msg, src_ip, dst_ip, src_subnet, dst_subnet)

        logging.getLogger('ryu').setLevel(logging.WARNING)
        logging.basicConfig(
            format='%(asctime)s | %(levelname)-8s | %(message)s',
            level=logging.INFO,
            datefmt='%H:%M:%S'
        )
        self.logger = logging.getLogger(__name__)

    def is_broadcast_mac(self, mac):
        return mac == 'ff:ff:ff:ff:ff:ff'

    def install_flows(self, datapath, src, dst, in_port, out_port):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        actions = [parser.OFPActionOutput(out_port)]
        match = parser.OFPMatch(in_port=in_port, eth_dst=dst, eth_src=src)
        self.add_flow(datapath, 1, match, actions)

    def get_subnet_name(self, ip_str):
        ip = ip_address(ip_str)
        for name, subnet in self.subnets.items():
            network = ip_network(subnet['network'], strict=False)
            if ip in network:
                return name
        return None

    def add_lease(self, mac, ip, subnet):
        lease_time = self.subnets[subnet]['lease_time']
        now = time.time()
        self.leases[mac] = {
            'ip': ip,
            'subnet': subnet,
            'lease_start': now,
            'lease_end': now + lease_time
        }
        self.log_dhcp(mac, "LEASE_ADDED", ip=ip, switch=subnet)

    def get_lease(self, mac):
        lease = self.leases.get(mac)
        if lease and lease['lease_end'] > time.time():
            return lease
        if lease:
            self.release_lease(mac)
        return None

    def release_lease(self, mac):
        lease = self.leases.pop(mac, None)
        if lease:
            self.subnets[lease['subnet']]['pool'].append(lease['ip'])
            self.log_dhcp(mac, "LEASE_RELEASED", ip=lease['ip'])

    def log_dhcp(self, mac, msg_type, switch=None, ip=None, xid=None):
        parts = []
        if switch:
            parts.append(f"SW={switch}")
        if ip:
            parts.append(f"IP={ip}")
        if xid:
            parts.append(f"XID={xid}")
        self.logger.info(f"[DHCP] MAC={mac} | {' | '.join(parts)} | {msg_type}")

    def log_packet_in(self, dpid, src, dst, in_port, pkt_type):
        self.logger.info(f"[PACKET-IN] SW={dpid} | SRC={src} | DST={dst} | PORT={in_port} | TYPE={pkt_type}")

    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser

        # Default flow to send unmatched packets to controller
        match = parser.OFPMatch()
        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]
        self.add_flow(datapath, 0, match, actions)

        # Flow for DHCP packets
        match_dhcp = parser.OFPMatch(
            eth_type=ether_types.ETH_TYPE_IP,
            ip_proto=17,
            udp_src=68,
            udp_dst=67
        )
        actions_dhcp = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER)]
        self.add_flow(datapath, 10, match_dhcp, actions_dhcp)

        # Add switch to network graph
        dpid = datapath.id
        if dpid not in self.net:
            self.net.add_node(dpid)
            self.switches[dpid] = datapath

    def add_flow(self, datapath, priority, match, actions, buffer_id=None):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)]
        if buffer_id:
            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id, priority=priority,
                                    match=match, instructions=inst)
        else:
            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,
                                    match=match, instructions=inst)
        datapath.send_msg(mod)

    def send_arp_reply(self, datapath, port, src_mac, dst_mac, src_ip, dst_ip):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        ether_pkt = ethernet.ethernet(
            dst=dst_mac,
            src=src_mac,
            ethertype=ether_types.ETH_TYPE_ARP
        )
        arp_pkt = arp.arp(
            opcode=arp.ARP_REPLY,
            src_mac=src_mac,
            src_ip=src_ip,
            dst_mac=dst_mac,
            dst_ip=dst_ip
        )
        pkt = packet.Packet()
        pkt.add_protocol(ether_pkt)
        pkt.add_protocol(arp_pkt)
        pkt.serialize()
        actions = [parser.OFPActionOutput(port)]
        out = parser.OFPPacketOut(
            datapath=datapath,
            buffer_id=ofproto.OFP_NO_BUFFER,
            in_port=ofproto.OFPP_CONTROLLER,
            actions=actions,
            data=pkt.data
        )
        datapath.send_msg(out)
        self.logger.debug(f"[ARP] Sent reply from {src_ip} to {dst_ip}")

    def send_arp_request(self, datapath, dpid, in_port, src_ip, target_ip):
        parser = datapath.ofproto_parser
        ofproto = datapath.ofproto
        src_mac = self.server_mac
        ether_pkt = ethernet.ethernet(
            dst='ff:ff:ff:ff:ff:ff',
            src=src_mac,
            ethertype=ether_types.ETH_TYPE_ARP
        )
        arp_pkt = arp.arp(
            opcode=arp.ARP_REQUEST,
            src_mac=src_mac,
            src_ip=src_ip,
            dst_mac='00:00:00:00:00:00',
            dst_ip=target_ip
        )
        pkt = packet.Packet()
        pkt.add_protocol(ether_pkt)
        pkt.add_protocol(arp_pkt)
        pkt.serialize()
        actions = [parser.OFPActionOutput(ofproto.OFPP_FLOOD)]
        out = parser.OFPPacketOut(
            datapath=datapath,
            buffer_id=ofproto.OFP_NO_BUFFER,
            in_port=ofproto.OFPP_CONTROLLER,
            actions=actions,
            data=pkt.data
        )
        datapath.send_msg(out)
        self.logger.debug(f"[ARP] Sent request for {target_ip}")

    def handle_inter_subnet_routing(self, datapath, src_ip, dst_ip, src_subnet, dst_subnet, in_port, msg):
        parser = datapath.ofproto_parser
        ofproto = datapath.ofproto
        dpid = datapath.id
        router_ip = self.subnets[dst_subnet]['router']
        router_mac = self.server_mac

        # تحقق هل لدينا MAC للراوتر
        if router_ip not in self.mac_to_port[dpid]:
            # خزّن الباكيت في pending_packets
            self.pending_packets.setdefault(router_ip, []).append((datapath, in_port, msg, src_ip, dst_ip, src_subnet, dst_subnet))
            self.send_arp_request(datapath, dpid, in_port, src_ip, router_ip)
            self.logger.info(f"[ROUTING] ARP request sent for router {router_ip}")
            return

        # إذا لدينا MAC للراوتر، أرسل الباكيت وثبّت flow
        out_port = self.mac_to_port[dpid][router_ip]
        actions = [parser.OFPActionOutput(out_port)]
        match = parser.OFPMatch(
            eth_type=ether_types.ETH_TYPE_IP,
            ipv4_dst=dst_ip
        )
        self.add_flow(datapath, 20, match, actions)
        data = msg.data if msg.buffer_id == ofproto.OFPCML_NO_BUFFER else None
        out = parser.OFPPacketOut(
            datapath=datapath,
            buffer_id=msg.buffer_id,
            in_port=in_port,
            actions=actions,
            data=data
        )
        datapath.send_msg(out)
        self.logger.info(f"[ROUTING] Installed route from {src_subnet} to {dst_subnet} via router {router_ip}")

    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler(self, ev):
        msg = ev.msg
        pkt = packet.Packet(msg.data)
        eth_pkt = pkt.get_protocol(ethernet.ethernet)
        ip_pkt = pkt.get_protocol(ipv4.ipv4)
        udp_pkt = pkt.get_protocol(udp.udp)
        dhcp_pkt = pkt.get_protocol(dhcp.dhcp)

        if eth_pkt and ip_pkt and udp_pkt and dhcp_pkt:
            if udp_pkt.src_port == 68 and udp_pkt.dst_port == 67:
                datapath = msg.datapath
                port = msg.match['in_port']
                mac = eth_pkt.src
                switch_id = datapath.id
                switch = f's{switch_id}'
                self.handle_dhcp(datapath, port, mac, dhcp_pkt, switch)
                return

        datapath = msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        in_port = msg.match['in_port']

        if ev.msg.msg_len < ev.msg.total_len:
            self.logger.debug("packet truncated: only %s of %s bytes",
                              ev.msg.msg_len, ev.msg.total_len)

        pkt = packet.Packet(msg.data)
        eth = pkt.get_protocols(ethernet.ethernet)[0]

        if eth.ethertype in (ether_types.ETH_TYPE_LLDP, ether_types.ETH_TYPE_IPV6):
            return

        dst = eth.dst
        src = eth.src
        dpid = datapath.id

        self.mac_to_port.setdefault(dpid, {})
        if src not in self.mac_to_port[dpid]:
            self.mac_to_port[dpid][src] = in_port
            self.logger.info("Learning MAC %s on port %s", src, in_port)
        elif self.mac_to_port[dpid][src] != in_port and self.is_broadcast_mac(dst):
            prio = 2
            actions = []
            match = parser.OFPMatch(eth_src=src, in_port=in_port)
            inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)]
            if msg.buffer_id != ofproto.OFP_NO_BUFFER:
                mod = parser.OFPFlowMod(datapath=datapath, buffer_id=msg.buffer_id, priority=prio, match=match,
                                        instructions=inst)
            else:
                mod = parser.OFPFlowMod(datapath=datapath, priority=prio, match=match, instructions=inst)
            datapath.send_msg(mod)
            self.logger.info("Dropping packet due to incorrect port")
            return

        if src not in self.net:
            self.net.add_node(src)
        self.net.add_edge(dpid, src, port=in_port)
        self.net.add_edge(src, dpid)

        if eth.ethertype == 0x0806:
            arp_pkt = pkt.get_protocol(arp.arp)
            if arp_pkt.opcode == arp.ARP_REQUEST:
                self.logger.info(f"[ARP] Request for IP: {arp_pkt.dst_ip} from {arp_pkt.src_ip}")
                switch = f's{datapath.id}'
                subnet_info = self.subnets.get(switch)
                if not subnet_info:
                    return
                dst_subnet = self.get_subnet_name(arp_pkt.dst_ip)
                src_subnet = self.get_subnet_name(arp_pkt.src_ip)
                # الرد على ARP للراوتر (gateway) لكل subnet
                if dst_subnet and arp_pkt.dst_ip == self.subnets[dst_subnet]['router']:
                    self.send_arp_reply(
                        datapath=datapath,
                        port=in_port,
                        src_mac=self.router_mac,
                        dst_mac=arp_pkt.src_mac,
                        src_ip=arp_pkt.dst_ip,
                        dst_ip=arp_pkt.src_ip
                    )
                    return
            elif arp_pkt.opcode == arp.ARP_REPLY:
                self.logger.info(f"[ARP] Received reply for {arp_pkt.src_ip}")
                self.mac_to_port[dpid][arp_pkt.src_mac] = in_port
                # تحقق إذا كان هناك باكيتات معلقة لهذا الـIP
                pending = self.pending_packets.pop(arp_pkt.src_ip, [])
                for (datapath, in_port, msg, src_ip, dst_ip, src_subnet, dst_subnet) in pending:
                    self.handle_inter_subnet_routing(datapath, src_ip, dst_ip, src_subnet, dst_subnet, in_port, msg)

            out_port = self.mac_to_port[dpid].get(dst, ofproto.OFPP_FLOOD)
            actions = [parser.OFPActionOutput(out_port)]
            data = msg.data if msg.buffer_id == ofproto.OFPCML_NO_BUFFER else None
            out = parser.OFPPacketOut(
                datapath=datapath,
                buffer_id=msg.buffer_id,
                in_port=in_port,
                actions=actions,
                data=data
            )
            datapath.send_msg(out)
            return

        elif eth.ethertype == 0x0800:
            ip_pkt = pkt.get_protocol(ipv4.ipv4)
            src_ip = ip_pkt.src
            dst_ip = ip_pkt.dst
            src_subnet = self.get_subnet_name(src_ip)
            dst_subnet = self.get_subnet_name(dst_ip)
            if not src_subnet or not dst_subnet:
                return

            # السماح بالتوجيه بين subnets
            if dst_subnet != src_subnet:
                self.logger.info(f"Routing between subnets: {src_subnet} -> {dst_subnet}")
                self.handle_inter_subnet_routing(datapath, src_ip, dst_ip, src_subnet, dst_subnet, in_port, msg)
                return

            if dst in self.mac_to_port[dpid]:
                out_port = self.mac_to_port[dpid][dst]
                actions = [parser.OFPActionOutput(out_port)]
                match = parser.OFPMatch(
                    eth_type=ether_types.ETH_TYPE_IP,
                    ipv4_src=src_ip,
                    ipv4_dst=dst_ip
                )
                self.add_flow(datapath, 1, match, actions)
                data = msg.data if msg.buffer_id == ofproto.OFPCML_NO_BUFFER else None
                out = parser.OFPPacketOut(
                    datapath=datapath,
                    buffer_id=msg.buffer_id,
                    in_port=in_port,
                    actions=actions,
                    data=data
                )
                datapath.send_msg(out)
                return

        if dst in self.net:
            try:
                paths = list(nx.all_shortest_paths(self.net, src, dst))
                if paths:
                    path = random.choice(paths)
                    self.paths[(src, dst)] = path
                    if dpid in path:
                        try:
                            next_node = path[path.index(dpid) + 1]
                            out_port = self.net[dpid][next_node]['port']
                            self.logger.info("Outputting packet to port %s", out_port)
                            self.logger.info("Path is : %s", str(path))
                            self.install_flows(datapath, src, dst, in_port, out_port)
                        except IndexError:
                            out_port = ofproto.OFPP_FLOOD
                            self.logger.info("No next node in path, flooding...")
                    else:
                        out_port = ofproto.OFPP_FLOOD
                        self.logger.info("dpid %s not in path, flooding...", dpid)
                else:
                    out_port = ofproto.OFPP_FLOOD
                    self.logger.info("No path found, flooding...")
            except nx.NetworkXNoPath:
                out_port = ofproto.OFPP_FLOOD
                self.logger.info("No path found, flooding...")
        else:
            out_port = ofproto.OFPP_FLOOD
            self.logger.info("Destination not found, flooding...")

        actions = [parser.OFPActionOutput(out_port)]
        data = None
        if msg.buffer_id == ofproto.OFPP_NO_BUFFER:
            data = msg.data
        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
                                  in_port=in_port, actions=actions, data=data)
        datapath.send_msg(out)

    # ========== DHCP Methods (unchanged) ==========
    def handle_dhcp(self, datapath, port, mac, dhcp_pkt, switch):
        xid = dhcp_pkt.xid
        msg_type = None
        for opt in dhcp_pkt.options.option_list:
            if opt.tag == self.DHCP_MESSAGE_TYPE:
                msg_type = opt.value[0]
                break
        if msg_type == self.DHCP_DISCOVER:
            self.log_dhcp(mac, "DISCOVER", switch=switch, xid=xid)
            self.process_dhcp_discover(datapath, port, mac, xid, switch)
        elif msg_type == self.DHCP_REQUEST:
            self.log_dhcp(mac, "REQUEST", switch=switch, xid=xid)
            self.process_dhcp_request(datapath, port, mac, dhcp_pkt, xid, switch)
        elif msg_type == self.DHCP_RELEASE:
            self.log_dhcp(mac, "RELEASE", switch=switch)
            self.release_lease(mac)
        else:
            self.log_dhcp(mac, f"UNKNOWN ({msg_type})", switch=switch)

    def process_dhcp_discover(self, datapath, port, mac, xid, switch):
        subnet = self.subnets.get(switch)
        if not subnet:
            self.log_dhcp(mac, f"NO_SUBNET ({switch})", xid=xid)
            return
        lease = self.get_lease(mac)
        if lease:
            ip = lease['ip']
        else:
            if not subnet['pool']:
                self.log_dhcp(mac, "POOL_EMPTY", xid=xid)
                return
            ip = subnet['pool'].pop(0)
            self.add_lease(mac, ip, switch)
        self.send_dhcp_offer(datapath, port, mac, ip, xid, switch)

    def process_dhcp_request(self, datapath, port, mac, dhcp_pkt, xid, switch):
        subnet_info = self.subnets.get(switch)
        if not subnet_info:
            self.log_dhcp(mac, "SUBNET_NOT_FOUND", xid=xid)
            self.send_dhcp_nak(datapath, port, mac, xid)
            return
        requested_ip = None
        for opt in dhcp_pkt.options.option_list:
            if opt.tag == self.DHCP_REQUESTED_IP:
                requested_ip = addrconv.ipv4.bin_to_text(opt.value)
        lease = self.get_lease(mac)
        if lease is None:
            self.log_dhcp(mac, "NO_LEASE", xid=xid)
            self.send_dhcp_nak(datapath, port, mac, xid)
            return
        if lease['ip'] != requested_ip or lease['subnet'] != switch:
            self.log_dhcp(mac, "IP_MISMATCH", ip=requested_ip, xid=xid)
            self.send_dhcp_nak(datapath, port, mac, xid)
            self.release_lease(mac)
        else:
            self.send_dhcp_ack(datapath, port, mac, lease['ip'], xid, switch)

    def build_dhcp_packet(self, mac, ip, msg_type, xid, switch):
        chaddr = addrconv.mac.text_to_bin(mac)
        subnet = self.subnets.get(switch, {})
        server_ip = subnet.get('server_ip', '0.0.0.0')
        options = dhcp.options(option_list=[
            dhcp.option(tag=self.DHCP_MESSAGE_TYPE, value=bytes([msg_type])),
            dhcp.option(tag=self.DHCP_SERVER_ID, value=addrconv.ipv4.text_to_bin(server_ip)),
            dhcp.option(tag=self.DHCP_LEASE_TIME, value=struct.pack('!I', subnet.get('lease_time', 0))),
            dhcp.option(tag=self.DHCP_SUBNET_MASK, value=addrconv.ipv4.text_to_bin(subnet.get('subnet_mask', '0.0.0.0'))),
            dhcp.option(tag=self.DHCP_ROUTER, value=addrconv.ipv4.text_to_bin(subnet.get('router', '0.0.0.0'))),
            dhcp.option(tag=self.DHCP_DNS_SERVER, value=addrconv.ipv4.text_to_bin(subnet.get('dns_server', '0.0.0.0'))),
            dhcp.option(tag=self.DHCP_DOMAIN_NAME, value=subnet.get('domain_name', '').encode()),
            dhcp.option(tag=self.DHCP_END, value=b'')
        ])
        pkt = packet.Packet()
        pkt.add_protocol(ethernet.ethernet(
            ethertype=ether_types.ETH_TYPE_IP, dst='ff:ff:ff:ff:ff:ff', src=self.server_mac))
        pkt.add_protocol(ipv4.ipv4(dst='255.255.255.255', src=server_ip, proto=17))
        pkt.add_protocol(udp.udp(src_port=67, dst_port=68))
        pkt.add_protocol(dhcp.dhcp(op=2, chaddr=chaddr, yiaddr=ip, siaddr=server_ip, xid=xid, options=options))
        pkt.serialize()
        return pkt

    def send_dhcp_offer(self, datapath, port, mac, ip, xid, switch):
        self.log_dhcp(mac, "OFFER_SENT", ip=ip, xid=xid)
        pkt = self.build_dhcp_packet(mac, ip, self.DHCP_OFFER, xid, switch)
        self.send_packet(datapath, port, pkt)

    def send_dhcp_ack(self, datapath, port, mac, ip, xid, switch):
        self.log_dhcp(mac, "ACK_SENT", ip=ip, xid=xid)
        pkt = self.build_dhcp_packet(mac, ip, self.DHCP_ACK, xid, switch)
        self.send_packet(datapath, port, pkt)

    def send_dhcp_nak(self, datapath, port, mac, xid):
        self.log_dhcp(mac, "NAK_SENT", xid=xid)
        pkt = self.build_dhcp_packet(mac, '0.0.0.0', self.DHCP_NAK, xid, None)
        self.send_packet(datapath, port, pkt)

    def send_packet(self, datapath, port, pkt):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        pkt.serialize()
        out = parser.OFPPacketOut(
            datapath=datapath,
            buffer_id=ofproto.OFP_NO_BUFFER,
            in_port=ofproto.OFPP_CONTROLLER,
            actions=[parser.OFPActionOutput(port)],
            data=pkt.data
        )
        datapath.send_msg(out)
        self.logger.debug(f"[DEBUG] Packet sent to port {port}") 